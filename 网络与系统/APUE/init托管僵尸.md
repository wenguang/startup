### init托管僵尸

子进程死后，成为僵尸，父进程通过wait或waitpid给它们收尸。父进程不想干收尸的工作啥办？

父进程说：滚~~ 到init进程那儿去，你的死活老子不管了，让它给你收尸吧。

从此之后，子进程就到孤儿院（init进程就是孤儿院院长）。

**SIGCHLD信号** 

```c
// 子进程死后会给父进程发SIGCHLD信号，让它老子知道它死了，好给它收尸
// 以下代码就是说：老子忽略该信号，让内核去处理它
signal(SIGCHLD, SIG_IGN);
```

**两次fork()** 

父进程一次fork()后产生一个子进程随后立即执行waitpid(子进程pid, NULL, 0)来等待子进程结束，然后子进程fork()后产生孙子进程随后立即_exit(0)。这样子进程顺利终止（父进程仅仅给子进程收尸，并不需要子进程的返回值），然后父进程继续执行。这时的孙子进程由于失去了它的父进程（即是父进程的子进程），将被转交给Init进程托管。于是父进程与孙子进程无继承关系了，它们的父进程均为Init，Init进程在其子进程结束时会自动收尸，这样也就不会产生僵尸进程了。



[linux下的僵尸进程处理SIGCHLD信号](http://www.cnblogs.com/wuchanming/p/4020463.html) 

[调用 fork() 两次以避免僵死进程](http://blog.csdn.net/dlutbrucezhang/article/details/8883339) 

