**协程** 、**子例程** 、**内核态** 、**用户态**、



[协程的简单理解](http://blog.jqian.net/post/coroutine.html) 

```objective-c
进程的上下文切换包括内存地址空间、内核态堆栈和硬件上下文(CPU寄存器)的切换，所以代价很高 

由于进程切换开销大，所以设计了线程。Linux 2.6内核的clone()系统调用已经支持创建内核级线程，且发布了内核线程库pthread 

线程可以共享进程的地址空间，线程仅需要维护自己的寄存器、栈和线程相关的变量。不过内核线程的调度仍然需要由内核完成，这需要进行用户态和内核态的模式切换，至少包括堆栈和内存映射的切换 

而协程始终运行在一个线程之内，完全没有上下文切换，因为它的上下文是维护在用户态开辟的一块内存里，而它的任务调度是在代码里显式处理的。目前Linux上可选用的纤程库是GNU Portable Threads(Pth)。 
 
他们最大的区别即在于对CPU的使用上(任务调度)：如前文所述，进程和线程的任务调度由内核控制，是抢占式的；而协程的任务调度在用户态完成，需要在代码里显式的把CPU交给其他协程，是协作式的。
  
我们可以简单认为协程是一种用户态线程
```



[C++开源协程库libco—原理及应用](https://wenku.baidu.com/view/cbbf9726dc36a32d7375a417866fb84ae45cc356.html?re=view) 

```objective-c
使用C++来编写高性能的网络服务器程序，从来都不是件很容易的事情。在没有应用任何网络框架，从epoll/kqueue直接码起的时候尤其如此。即便使用libevent,libev这样事件驱动的网络框架去构建你的服务，程序结构依然不会很简单。为何会这样？因为这类框架提供的都是非阻塞式的、异步的编程接口，异步的编程方式，这需要思维方式的转变。为什么golang近几年能够大规模流行起来呢？因为简单。这方面最突出的一点便是它的网络编程API，完全同步阻塞式的接口。要并发？go出一个协程就好了。
  
在go语言的API里，你找不到像epoll/kqueue之类的I/O多路复用（I/Omultiplexing）接口，那它是怎么做到轻松支持数万乃至十多万高并发的网络IO的呢？在Linux或其他类Unix系统里，支持I/O多路复用事件通知的系统调用（SystemCall）不外乎epoll/kqueue，它难道可以离开这些系统接口另起炉灶？这个自然是不可能的。聪明的读者，应该大致想到了这背后是怎么个原理了
  
非对称协程（asymmetriccoroutines）
它是跟一个特定的调用者绑定的，协程让出CPU时，只能让回给原调用者。那到底是什么东西“不对称”呢？其实，非对称在于程序控制流转移到被调协程时使用的是call/resume操作，而当被调协程让出CPU时使用的却是return/yield操作。此外，协程间的地位也不对等，caller与callee关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。
  
对称协程（symmetriccoroutines）
它启动之后就跟启动之前的协程没有任何关系了。协程的切换操作，一般而言只有一个操作，yield，用于将程序控制流转移给另外的协程。对称协程机制一般需要一个调度器的支持，按一定调度算法去选择yield的目标协程。
  
Go语言提供的协程，其实就是典型的对称协程。
```


