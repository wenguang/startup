**读写相关的注释翻译** 

```objective-c
maybeDequeueRead方法的注释
/**
 * This method starts a new read, if needed.
 * 
 * It is called when:
 * - a user requests a read
 * - after a read request has finished (to handle the next request)
 * - immediately after the socket opens to handle any pending requests
 * 
 * This method also handles auto-disconnect post read/write completion.
**/
/** 
 * 如果有需要，该方法会开始新的读取操作
 *
 * 该方法在以下情况被调用
 * —— 外部调用readDataWithXXX请求读取操作
 * —— 一个读取操作完成，处理下个一个读取请求前
 * —— 一打开的socketFD的stream或gcd对socketFD的读取事件时
 *
 * 该方法还会处理也自动断开连接的读写收尾工作
 **/
- (void)maybeDequeueRead;



/*预缓冲区对象*/
GCDAsyncSocketPreBuffer
  
 
/*
它封装了业务方向socket读取的数据包，业务方的一次读取请求，可能需要向预缓冲区或socket多次读取，只有满足了一定数据长度或读到结束符才一个完整的数据包，叫它读取包
*/
GCDAsyncReadPacket 


@public
	NSMutableData *buffer;	//数据包缓冲区，可由初始化参数传入，否则创建一个
	NSUInteger startOffset;	//数据写入buffer的起始位置，因为一个完整数据可能需要多次从prebuffer队列或socket读取才能得到
	NSUInteger bytesDone;	//未理解该字段的实际作用~~~
	NSUInteger maxLength;	//
	NSTimeInterval timeout; //超时时间
	NSUInteger readLength;	//一个完整数据包的长度
	NSData *term;		   	//一个完整数据包的结束符
	BOOL bufferOwner;	//当初始化参数传入buffer，该字段为NO，否则为YES
	NSUInteger originalBufferLength;	//等于初始化参数传入的buffer长度，否则为0
	long tag;
/*
按ensureCapacityForAdditionalDataOfLength方法的实现，对startOffset、bytesDone的理解又有歧义，原因如果按字段以上字段注释的解释，startOffset等于bytesDone，要么就是数据被写入buffer后，GCDAsyncReadPacket不会更新startOffset的值，而只更新bytesDone的值
*/
NSUInteger buffSize = [buffer length];
NSUInteger buffUsed = startOffset + bytesDone;
NSUInteger buffSpace = buffSize - buffUsed;

// 当需要向buffer写入bytesToRead字节的数据时，若buffer容量不足则扩容
- (void)ensureCapacityForAdditionalDataOfLength:(NSUInteger)bytesToRead

/*
当我们不知道从套接字读取多少数据时，会使用此方法。 此方法返回默认值，除非它超过指定的readLength或maxLength。此外，shouldPreBuffer取决于数据包类型，以及返回的值是否适合当前buffer，而不需要调整buffer大小。它返回最佳长度
*/
- (NSUInteger)optimalReadLengthWithDefault:(NSUInteger)defaultValue shouldPreBuffer:(BOOL *)shouldPreBufferPtr
  
/*
对于没有设置终止符的读取包，返回可以读取而不超过readLength或maxLength的数据量。 给定的参数指示在计算过程中考虑的估计在套接字上可用的字节数。 给定的提示必须大于零。
*/
- (NSUInteger)readLengthForNonTermWithHint:(NSUInteger)bytesAvailable
  
/*
对于具有设置终止符的读取数据包，返回可以读取而不超过maxLength的数据量。 给定的参数指示在计算过程中考虑的估计在套接字上可用的字节数。 要优化内存分配，mem副本和mem移动，shouldPreBuffer布尔值将指示数据是否应首先读入预缓冲区，或者数据可以直接读入读取数据包的缓冲区。
*/
- (NSUInteger)readLengthForTermWithHint:(NSUInteger)bytesAvailable shouldPreBuffer:(BOOL *)shouldPreBufferPtr
{
    /*
    数据是否应读入读取数据包的缓冲区，还是首先进入预缓冲区？

    人们会想到，首选的选择是哪个更快。那么哪一个更快？

    直接读入数据包缓冲区需要：
    可能调整包缓冲区大小（malloc / realloc）
    2.填充缓冲区（读）
    3.搜索终止符（memcmp）
    4.可能将溢出复制到prebuffer（malloc / realloc，memcpy）

    先读入预缓冲区需要：
    可能调整预缓冲区大小（malloc / realloc）
    2.填充缓冲区（读）
    3.搜索终止符（memcmp）
    4.将下溢复制到包缓冲区（malloc / realloc，memcpy）
    5.从预缓冲器中清除下溢（memmove）

    乍一看，读入预缓冲区较慢些，因为它多了一步内存移动的操作。

    然而：
    NSMutableData的实现是通过核心基础的CFMutableData开源的。
    减少可变数据对象的长度不会导致realloc。
    换句话说，可变数据对象的容量可以增长，但不会缩小。

    这意味着prebuffer很少需要一个realloc。
    而数据包缓冲区通常可能需要realloc。
    如果我们是缓冲区所有者，这一点尤其如此。
    此外，如果我们不断重新分配包缓冲区，
    然后将溢出物移动到预缓冲器中，
    那么我们一直在为每个读取的术语分配内存。
    而现在我们可以在速度和内存利用率之间进行一些权衡。

    最终的结果是2者的性能非常相似。
    那我们另一种方式简单地回答原来的问题。

    如果我们可以将所有的数据直接读入数据包的缓冲区，而不必首先调整它的大小，
    那么我们这样做，否则我们使用预缓冲区。
    */
	if (shouldPreBufferPtr)
}

/*
对于具有设置终止符的读取数据包，返回可以从preBuffer读取的而不超过终止符或maxLength的数据量。假定终止符尚未被读取。
*/
- (NSUInteger)readLengthForTermWithPreBuffer:(GCDAsyncSocketPreBuffer *)preBuffer found:(BOOL *)foundPtr
{
  	/*
  	我们知道终结者作为一个整体，不存在于我们自己的缓冲区。
    但是我们的缓冲区中可能存在_countion_。
    所以我们要从我们自己的缓冲区的一部分开始寻找终结符。

    例：
    终止符长度= 3字节
    bytesDone = 5个字节
    preBuffer长度= 5字节

    如果我们将preBuffer附加到缓冲区，
    它会像这样：
     ---------------------
	 |B|B|B|B|B|P|P|P|P|P|
	 ---------------------
    所以我们在这里开始搜索：
     ---------------------
	 |B|B|B|B|B|P|P|P|P|P|
	 -------^-^-^---------
    向前移动
     ---------------------
	 |B|B|B|B|B|P|P|P|P|P|
	 ---------^-^-^-------
    直到找到终止符。
     ---------------------
	 |B|B|B|B|B|P|P|P|P|P|
	 ---------------^-^-^-
    */
}
```









**读取数据相关的疑问**  

1、从didConnect方法看出，同时开启2种方式读取数据，1是gcd source来监听socketFD的读取事件，2是从socketFD创建出CFReadStream来做读取。这2个流程都在回调中调用了doReadData方法。不这冲突吗？

2、CFStream是在cfstreamThread中调度的，cfstreamThread是static的，这样设计有什么好处吗？cfstreamThread的实现看不懂~



**doReadData** 

光看doReadData方法的代码，那叫一个长，逻辑很多。

**read调用路径** 

1、readDataXXX—>maybeDequeueRead—>doReadData

2、didConnect—>maybeDequeueRead—>doReadData

3、CFReadStreamCallback—>cf_finishSSLHandshake—>maybeDequeueRead—>doReadData

4、maybeStartTLS—>ssl_startTLS—>ssl_continueSSLHandshake—>maybeDequeueRead—>doReadData

5、ssl_shouldTrustPeer—>ssl_continueSSLHandshake—>maybeDequeueRead—>doReadData

6、startTLS—>maybeDequeueRead—>doReadData

7、doReadData—>maybeDequeueRead—>doReadData



