#### 两台虚拟器间的连不通的问题 

cient.c、server.c在不同的centos虚拟机环境也

同一虚拟机可以连接成功，不同虚拟器连接异常：

server用环路ip bind，在启动firewall时(service firewalld restart)，cient的connect函数抛出：no route to host，在停止firewall时，client的connect函数抛出：connect refused

*解决方法* 

https://www.centos.org/forums/viewtopic.php?t=57032 这里提到

> It is only listening to port xxx on localhost, not your lan interface.

**原因：用sockaddr_in构建一个地址，指定ip为127.0.0.1，它只是一个环路地址，只在在同一虚拟机上连接成功。应该用getifadds函数获取网卡信息，获得enp0s3上为AF_INET的地址，应该要enp0s3所在的ip上监听才行**。

虚拟机上ifconfig的信息如下：

```shell
enp0s3: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.104  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::9734:ffea:1940:3c93  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:1e:b2:7a  txqueuelen 1000  (Ethernet)
        RX packets 106341  bytes 105557442 (100.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 53965  bytes 4743821 (4.5 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1  (Local Loopback)
        RX packets 76  bytes 5736 (5.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 76  bytes 5736 (5.6 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```



#### 服务端CLOSE-WAIT问题

用netstat -at命令查看tcp端口，发现很多端口处于**CLOSE-WAIT**状态：

```shell
tcp        2      0 localhost:etlservicemgr 192.168.1.103:49182     CLOSE_WAIT 
tcp        3      0 localhost:etlservicemgr 192.168.1.103:65455     CLOSE_WAIT 
tcp        2      0 localhost:etlservicemgr 192.168.1.103:65339     CLOSE_WAIT 
tcp        1      0 localhost:etlservicemgr 192.168.1.103:65154     CLOSE_WAIT 
tcp        4      0 localhost:etlservicemgr 192.168.1.103:65499     CLOSE_WAIT 
tcp        2      0 localhost:etlservicemgr 192.168.1.103:65336     CLOSE_WAIT 
tcp        1      0 localhost:etlservicemgr 192.168.1.103:63172     CLOSE_WAIT 
tcp        1      0 localhost:etlservicemgr 192.168.1.103:65139     CLOSE_WAIT 
```

用wireshark抓包发现客户端close函数后，也只有4次挥手的中的2次：【FIN, ACK】和【ACK】，这时服务端处于**CLOSE-WAIT**状态，**原因是服务端没有调用close函数关掉通信链路，大量端口长期处于CLOSE-WAIT状态会使服务器Down掉。所以，服务端应该在客户端发出close请求或客户端超时时close掉链路**。 



#### accept函数 阻塞 非阻塞

在epoll_wait的一次返回中，有可能listen多个连接等待accept的情况，这在高并发的环境经常发生，那就要在一个while循环中调用accept函数，直到accept函数返回-1才算是接收等待的连接。如果负责监听的socketfd是阻塞的（新创建的socket默认是阻塞的），accept函数在没有了等待接收的连接时，它就会阻塞着不返回。所以要设置监听socket的非阻塞属性。



#### EAGAIN EWOULDBLOCK

在centos7中，这两个错误码值是一样的（有些老的unix系统它们的码值不一样），它们意思是：

> [EAGAIN](https://web.archive.org/web/20130508062559/http://www.wlug.org.nz/EAGAIN) is often raised when performing [non-blocking I/O](http://www.kegel.com/dkftpbench/nonblocking.html). It means *"there is no data available right now, try again later"*.
>
> It [might](http://www.opengroup.org/onlinepubs/000095399/basedefs/errno.h.html) (or [might not](http://mail-archives.apache.org/mod_mbox/httpd-dev/200004.mbox/%3CE12edKw-0002M2-00@fanf.eng.demon.net%3E)) be the same as `EWOULDBLOCK`, which means *"your thread would have to block in order to do that"*.

在accept、read等函数中经常遇到这两个错误，要注意区分这两个错误与其它错误，以上解释中可看到它们非真正的系统出错。



#### g++在linux上编译，inet_addr函数不起作用 

c++已经不抛弃了inet_addr函数，它只适用于ipv4，用inet_pton函数即行，它兼容ipv4和ipv6



#### EPOLLIN如何区分可读与对方socket关闭

这两种事件都会触发EPOLLIN，当有EPOLLIN事件，用getsockopt函数获取tcp_info，通过tcp_info的tcpi_state判断连接状态，这些状态在3次握手和4次挥手中有定义

头文件: *\<netinet/tcp.h\>* 

```c
enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING   /* now a valid state */
};
```





