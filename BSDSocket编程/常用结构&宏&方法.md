```objective-c
sockaddr4.sin_port = htons(port);
sockaddr4.sin_addr.s_addr = htonl(INADDR_ANY);

sockaddr6.sin6_addr = in6addr_any;

// <sys/_endian.h>
#define htons(x)	__DARWIN_OSSwapInt16(x)

// <netinet6/in6.h>
extern const struct in6_addr in6addr_any;

// <netinet/in.h>
#define	INADDR_ANY		(u_int32_t)0x00000000
#define	INADDR_LOOPBACK		(u_int32_t)0x7f000001

// <netinet/in.h>
#define INET_ADDRSTRLEN                 16
// <netinet6/in6.h>
#define INET6_ADDRSTRLEN                 64


// 
long portL = strtol([[components objectAtIndex:1] UTF8String], NULL, 10);

/**
str 为要转换的字符串，endstr 为第一个不能转换的字符的指针，base 为字符串 str 所采用的进制，参数 base 范围从2 至36，或0。参数base 代表 str 采用的进制方式，如base 值为10 则采用10 进制，若base 值为16 则采用16 进制等。两点注意：
当 base 的值为 0 时，默认采用 10 进制转换，但如果遇到 '0x' / '0X' 前置字符则会使用 16 进制转换，遇到 '0' 前置字符则会使用 8 进制转换。
若endptr 不为NULL，则会将遇到的不符合条件而终止的字符指针由 endptr 传回；若 endptr 为 NULL，则表示该参数无效，或不使用该参数。
*/
long int strtol (const char* str, char** endptr, int base);



struct sockaddr_in saddr;  
bzero(&saddr,sizeof(saddr)); 
```

【socket文件描述符】

```c
// socket4FD，FD（file descriptor），在BSD socket中socket句柄被当作文件，对socket的读写相当对文件读写
int socket4FD;
int socket6FD;
int socketUN;
```

【地址相关的struct】

```objective-c
// <sys/socket.h>
struct sockaddr {
	__uint8_t	sa_len;		/* total length */
	sa_family_t	sa_family;	/* [XSI] address family */
	char		sa_data[14];	/* [XSI] addr value (actually larger) */
};
// <netinet/in.h>
struct sockaddr_in {
	__uint8_t	sin_len;
	sa_family_t	sin_family;
	in_port_t	sin_port;
	struct	in_addr sin_addr;
	char		sin_zero[8];
};
// <netinet6/in6.h>
struct sockaddr_in6 {
	__uint8_t	sin6_len;	/* length of this struct(sa_family_t) */
	sa_family_t	sin6_family;	/* AF_INET6 (sa_family_t) */
	in_port_t	sin6_port;	/* Transport layer port # (in_port_t) */
	__uint32_t	sin6_flowinfo;	/* IP6 flow information */
	struct in6_addr	sin6_addr;	/* IP6 address */
	__uint32_t	sin6_scope_id;	/* scope zone index */
};
// <sys/un.h>
struct	sockaddr_un {
	unsigned char	sun_len;	/* sockaddr len including null */
	sa_family_t	sun_family;	/* [XSI] AF_UNIX */
	char		sun_path[104];	/* [XSI] path name (gag) */
};
// <netdb.h>
struct addrinfo {
	int	ai_flags;	/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
	int	ai_family;	/* PF_xxx */
	int	ai_socktype;	/* SOCK_xxx */
	int	ai_protocol;	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */
	socklen_t ai_addrlen;	/* length of ai_addr */
	char	*ai_canonname;	/* canonical name for hostname */
	struct	sockaddr *ai_addr;	/* binary address */
	struct	addrinfo *ai_next;	/* next structure in linked list */
};
// ai_flags可取的值
AI_ADDRCONFIG		//查询配置的地址类型(IPv4或IPv6)
AI_ALL				//查找IPv4和IPv6
AI_CANONNAME		//需要一个规范名
AI_NUMERICHOST		//以数字格式返回主机地址
AI_NUMERICSERV		//以端口号返回服务
AI_PASSIVE			//套接字地址用于监听绑定
AI_V4MAPPED			//如果没有找到IPv4地址，则返回映射到IPv6格式

// <ifaddrs.h>
struct ifaddrs {
  struct ifaddrs  *ifa_next;
  char		*ifa_name;
  unsigned int	 ifa_flags;
  struct sockaddr	*ifa_addr;
  struct sockaddr	*ifa_netmask;
  struct sockaddr	*ifa_dstaddr;
  void		*ifa_data;
};

/*
* This may have been defined in <net/if.h>.  Note that if <net/if.h> is
* to be included it must be included before this header file.
*/
#ifndef	ifa_broadaddr
#define	ifa_broadaddr	ifa_dstaddr	/* broadcast address interface */
#endif

struct ifmaddrs {
  struct ifmaddrs	*ifma_next;
  struct sockaddr	*ifma_name;
  struct sockaddr	*ifma_addr;
  struct sockaddr	*ifma_lladdr;
};

```





